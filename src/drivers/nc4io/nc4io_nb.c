/* Do not edit this file. It is produced from the corresponding .m4 source */
/*
 *  Copyright (C) 2018, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* Note, netcdf header must come first due to conflicting constant definition */
#include <common.h>
#include <mpi.h>
#include <netcdf.h>
#include <netcdf_par.h>
#include <pnc_debug.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "nc4io_driver.h"

#define REQ_LIST_BASE_SIZE  32
#define REQ_LIST_MULTIPLIER 2

int nc4ioi_req_list_init (nc4_req_list *list) {
    int i;

    list->nused  = 0;
    list->nalloc = REQ_LIST_BASE_SIZE;
    list->items  = (nc4_req *)NCI_Malloc (sizeof (nc4_req) * list->nalloc);
    if (!(list->items)) { DEBUG_RETURN_ERROR (NC_ENOMEM); }
    list->idx = (int *)NCI_Malloc (sizeof (int) * list->nalloc);
    if (!(list->idx)) { DEBUG_RETURN_ERROR (NC_ENOMEM); }

    for (i = 0; i < list->nalloc; i++) {
        list->idx[i]       = i;
        list->items[i].vid = -1;
    }

    return NC_NOERR;
}

int nc4ioi_req_list_free (nc4_req_list *list) {
    int i;

    NCI_Free (list->items);
    NCI_Free (list->idx);

    return NC_NOERR;
}

int nc4ioi_req_list_insert (nc4_req_list *list, nc4_req req, int *idx) {
    int i;
    int id;
    size_t newsize;

    if (req.vid < 0) DEBUG_RETURN_ERROR (NC_EINVAL)

    if (list->nused == list->nalloc) {
        newsize     = list->nalloc * REQ_LIST_MULTIPLIER;
        list->items = (nc4_req *)NCI_Realloc (list->items, sizeof (nc4_req) * newsize);
        if (!(list->items)) { DEBUG_RETURN_ERROR (NC_ENOMEM); }
        list->idx = (int *)NCI_Realloc (list->idx, sizeof (int) * newsize);
        if (!(list->idx)) { DEBUG_RETURN_ERROR (NC_ENOMEM); }

        for (i = list->nalloc; i < newsize; i++) {
            list->idx[i]       = i;
            list->items[i].vid = -1;
        }

        list->nalloc = newsize;
    }

    req.idp         = list->nused;
    id              = list->idx[list->nused++];
    list->items[id] = req;
    if (idx) *idx = id;

    return NC_NOERR;
}

int nc4ioi_req_list_remove (nc4_req_list *list, int idx) {
    if (idx < 0 || idx > list->nalloc) { DEBUG_RETURN_ERROR (NC_EINVAL) }

    if (list->items[idx].vid < 0) { DEBUG_RETURN_ERROR (NC_EINVAL) }

    list->items[idx].vid = -1;
    if (list->items[idx].xbuf != list->items[idx].ubuf) { NCI_Free (list->items[idx].xbuf); }
    list->nused--;

    list->items[list->idx[list->nused]].idp = list->items[idx].idp;
    list->idx[list->items[idx].idp]         = list->idx[list->nused];
    list->idx[list->nused]                  = idx;

    return NC_NOERR;
}

int nc4ioi_req_init (NC_nc4 *nc4p,
                     nc4_req *req,
                     int varid,
                     const MPI_Offset *start,
                     const MPI_Offset *count,
                     const MPI_Offset *stride,
                     const MPI_Offset *imap,
                     const void *buf,
                     MPI_Datatype buftype,
                     const int cp) {
    int err;
    int i;
    int ndim, dimid;
    MPI_Offset *dlens = NULL;
    size_t dlen, rsize;
    int esize;

    /* Inq variable dim */
    err = nc_inq_varndims (nc4p->ncid, varid, &ndim);
    if (err != NC_NOERR) goto fn_exit;

    MPI_Type_size (buftype, &esize);

    req->vid     = varid;
    req->ubuf    = (char *)buf;
    req->buftype = buftype;
    req->apikind = NC4_API_KIND_VAR;
    req->start   = NULL;
    req->count   = NULL;
    req->stride  = NULL;
    req->imap    = NULL;
    req->next    = -1;
    if (cp) {
        if (!count) {
            /* Inq variable dim */
            err = nc_inq_varndims (nc4p->ncid, varid, &ndim);
            if (err != NC_NOERR) goto fn_exit;

            dlens = (MPI_Offset *)NCI_Malloc (sizeof (MPI_Offset) * ndim);
            if (!dlens) { goto fn_exit; }

            if (start) {
                for (i = 0; i < ndim; i++) { dlens[i] = 1; }
            } else {
                for (i = 0; i < ndim; i++) {
                    err = nc_inq_vardimid (nc4p->ncid, varid, &dimid);
                    if (err != NC_NOERR) goto fn_exit;
                    err = nc_inq_dimlen (nc4p->ncid, dimid, &dlen);
                    if (err != NC_NOERR) goto fn_exit;
                    dlens[i] = (MPI_Offset)dlen;
                }
            }
        } else {
            dlens = (MPI_Offset *)count;
        }

        rsize = esize;
        for (i = 0; i < ndim; i++) { rsize *= dlens[i]; }
        req->xbuf = NCI_Malloc (rsize);
        if (!(req->xbuf)) {
            DEBUG_ASSIGN_ERROR (err, NC_ENOMEM)
            goto fn_exit;
        }
        memcpy (req->xbuf, buf, rsize);

    } else {
        req->xbuf = (void *)buf;
    }

    if (start) {
        req->start = (MPI_Offset *)NCI_Malloc (sizeof (MPI_Offset) * ndim);
        if (!(req->start)) {
            DEBUG_ASSIGN_ERROR (err, NC_ENOMEM)
            goto fn_exit;
        }

        req->apikind = NC4_API_KIND_VAR1;
        memcpy (req->start, start, sizeof (MPI_Offset) * ndim);
    }

    if (count) {
        req->count = (MPI_Offset *)NCI_Malloc (sizeof (MPI_Offset) * ndim);
        if (!(req->count)) {
            DEBUG_ASSIGN_ERROR (err, NC_ENOMEM)
            goto fn_exit;
        }

        req->apikind = NC4_API_KIND_VARA;
        memcpy (req->count, count, sizeof (MPI_Offset) * ndim);
    }

    if (stride) {
        req->stride = (MPI_Offset *)NCI_Malloc (sizeof (MPI_Offset) * ndim);
        if (!(req->stride)) {
            DEBUG_ASSIGN_ERROR (err, NC_ENOMEM)
            goto fn_exit;
        }

        req->apikind = NC4_API_KIND_VARS;
        memcpy (req->stride, stride, sizeof (MPI_Offset) * ndim);
    }

    if (imap) {
        req->imap = (MPI_Offset *)NCI_Malloc (sizeof (MPI_Offset) * ndim);
        if (!(req->imap)) {
            DEBUG_ASSIGN_ERROR (err, NC_ENOMEM)
            goto fn_exit;
        }
        req->apikind = NC4_API_KIND_VARM;
        memcpy (req->stride, imap, sizeof (MPI_Offset) * ndim);
    }

fn_exit:;
    if (err != NC_NOERR) {
        NCI_Free (req->start);
        NCI_Free (req->count);
        NCI_Free (req->stride);
        NCI_Free (req->imap);
        if (cp) { NCI_Free (req->xbuf); }
    }

    if (dlens != count) NCI_Free (dlens);

    return err;
}

int nc4ioi_igetput_var (NC_nc4 *nc4p,
                        nc4_req_list *list,
                        int varid,
                        const MPI_Offset *start,
                        const MPI_Offset *count,
                        const MPI_Offset *stride,
                        const MPI_Offset *imap,
                        const void *buf,
                        MPI_Datatype buftype,
                        int *reqid,
                        int reqMode,
                        int cp) {
    int err;
    nc4_req req;

    if (!fIsSet (nc4p->flag, NC_MODE_INDEP)) {
        err = nc_var_par_access (nc4p->ncid, varid, NC_INDEPENDENT);
        if (err != NC_NOERR) DEBUG_RETURN_ERROR (err);
    }

    err = nc4ioi_req_init (nc4p, &req, varid, start, count, stride, imap, buf, buftype, cp);
    if (err != NC_NOERR) goto fn_exit;

    err = nc4ioi_req_list_insert (list, req, reqid);
    if (err != NC_NOERR) goto fn_exit;

    if (!fIsSet (nc4p->flag, NC_MODE_INDEP)) {
        err = nc_var_par_access (nc4p->ncid, varid, NC_COLLECTIVE);
        if (err != NC_NOERR) DEBUG_RETURN_ERROR (err);
    }

fn_exit:;
    return err;
}

int nc4ioi_igetput_varn (NC_nc4 *nc4p,
                         nc4_req_list *list,
                         int varid,
                         int nreq,
                         MPI_Offset *const *starts,
                         MPI_Offset *const *counts,
                         const void *buf,
                         MPI_Datatype buftype,
                         int *reqid,
                         int reqMode,
                         int cp) {
    int err;
    int i, j;
    int curid, prvid, ndim;
    int esize;
    size_t rsize;
    char *bufp;
    nc4_req req;

    if (!fIsSet (nc4p->flag, NC_MODE_INDEP)) {
        err = nc_var_par_access (nc4p->ncid, varid, NC_INDEPENDENT);
        if (err != NC_NOERR) DEBUG_RETURN_ERROR (err);
    }

    /* Inq variable dim */
    err = nc_inq_varndims (nc4p->ncid, varid, &ndim);
    if (err != NC_NOERR) goto fn_exit;

    MPI_Type_size (buftype, &esize);
    bufp = (char *)buf;

    for (i = 0; i < nreq; i++) {
        rsize = esize;
        for (j = 0; j < ndim; j++) { rsize *= counts[i][j]; }
        if (counts) {
            err = nc4ioi_req_init (nc4p, &req, varid, starts[i], counts[i], NULL, NULL, bufp,
                                   buftype, cp);
            if (err != NC_NOERR) goto fn_exit;
        } else {
            err =
                nc4ioi_req_init (nc4p, &req, varid, starts[i], NULL, NULL, NULL, bufp, buftype, cp);
            if (err != NC_NOERR) goto fn_exit;
        }

        bufp += rsize;

        err = nc4ioi_req_list_insert (list, req, &curid);
        if (err != NC_NOERR) goto fn_exit;

        if (i) {
            list->items[prvid].next = curid;
        } else {
            if (reqid) *reqid = curid;
        }

        prvid = curid;
    }

    if (!fIsSet (nc4p->flag, NC_MODE_INDEP)) {
        err = nc_var_par_access (nc4p->ncid, varid, NC_COLLECTIVE);
        if (err != NC_NOERR) DEBUG_RETURN_ERROR (err);
    }

fn_exit:;
    return err;
}

int cmpfunc (const void *a, const void *b) {
    nc4_req *ap = (nc4_req *)a;
    nc4_req *bp = (nc4_req *)b;
    return ((ap->vid * NC4_NUM_API_KIND + ap->apikind) -
            (bp->vid * NC4_NUM_API_KIND + bp->apikind));
}

int nc4ioi_flush_write_reqs (NC_nc4 *nc4p, int nreq, nc4_req *reqs, int *statuses, int coll) {
    int err;
    int i;
    int nvar;
    int *cnt = NULL, *cnt_all = NULL;
    nc4_req **reqps = NULL;
    nc4_req *rp;
    MPI_Request mpireq;
    MPI_Status mpistat;

    err = nc_inq (nc4p->ncid, NULL, &nvar, NULL, NULL);
    if (err != NC_NOERR) { DEBUG_RETURN_ERROR (err) }

    cnt = (int *)NCI_Malloc (sizeof (int) * (size_t)nvar * NC4_NUM_API_KIND * 2);
    if (!cnt) {
        DEBUG_ASSIGN_ERROR (err, NC_ENOMEM);
        goto fn_exit;
    }
    cnt_all = cnt + (size_t)nvar * NC4_NUM_API_KIND;

    reqps = (nc4_req **)NCI_Malloc (sizeof (nc4_req *) * nvar * NC4_NUM_API_KIND);
    if (!reqps) {
        DEBUG_ASSIGN_ERROR (err, NC_ENOMEM);
        goto fn_exit;
    }

    memset (cnt, 0, sizeof (int) * nvar * NC4_NUM_API_KIND);
    for (i = 0; i < nreq; i++) { cnt[reqs[i].vid * NC4_NUM_API_KIND + reqs[i].apikind]++; }
    if (coll) {
        err = MPI_Iallreduce (cnt, cnt_all, nvar * NC4_NUM_API_KIND, MPI_INT, MPI_MIN, nc4p->comm,
                              &mpireq);
        if (err != MPI_SUCCESS) {
            DEBUG_ASSIGN_ERROR (err, NC_EMPI)
            goto fn_exit;
        }
    } else {
        memset (cnt_all, 0, sizeof (int) * nvar * NC4_NUM_API_KIND);
    }

    qsort (reqs, nreq, sizeof (nc4_req), cmpfunc);

    reqps[0] = reqs;
    for (i = 1; i < nvar * NC4_NUM_API_KIND; i++) { reqps[i] = reqps[i - 1] + cnt[i - 1]; }

    if (coll) {
        err = MPI_Wait (&mpireq, &mpistat);
        if (err != MPI_SUCCESS) {
            if (err == MPI_ERR_IN_STATUS) err = mpistat.MPI_ERROR;

            DEBUG_ASSIGN_ERROR (err, NC_EMPI)
            goto fn_exit;
        }

        for (i = 0; i < nvar * NC4_NUM_API_KIND; i++) {
            for (rp = reqps[i]; rp < reqps[i] + cnt_all[i]; rp++) {
                err = nc4io_put_var (nc4p, rp->vid, rp->start, rp->count, rp->stride, rp->imap,
                                     rp->xbuf, -1, rp->buftype, NC_REQ_WR | NC_REQ_COLL);
                if (rp->idp >= 0 && statuses) {
                    if (statuses[rp->idp] == NC_NOERR) statuses[rp->idp] = err;
                }
            }
        }

        err = nc4io_begin_indep_data (nc4p);
        if (err != NC_NOERR) goto fn_exit;
    }

    for (i = 0; i < nvar * NC4_NUM_API_KIND; i++) {
        for (rp = reqps[i]; rp < reqps[i] + cnt_all[i]; rp++) {
            err = nc4io_put_var (nc4p, rp->vid, rp->start, rp->count, rp->stride, rp->imap,
                                 rp->xbuf, -1, rp->buftype, NC_REQ_WR | NC_REQ_INDEP);
            if (rp->idp >= 0 && statuses) {
                if (statuses[rp->idp] == NC_NOERR) statuses[rp->idp] = err;
            }
        }
    }

    if (coll) {
        err = nc4io_end_indep_data (nc4p);
        if (err != NC_NOERR) goto fn_exit;
    }

fn_exit:;
    return err;
}

int nc4ioi_flush_read_reqs (NC_nc4 *nc4p, int nreq, nc4_req *reqs, int *statuses, int coll) {
    int err;
    int i;
    int nvar;
    int *cnt = NULL, *cnt_all = NULL;
    nc4_req **reqps = NULL;
    nc4_req *rp;
    MPI_Request mpireq;
    MPI_Status mpistat;

    err = nc_inq (nc4p->ncid, NULL, &nvar, NULL, NULL);
    if (err != NC_NOERR) { DEBUG_RETURN_ERROR (err) }

    cnt = (int *)NCI_Malloc (sizeof (int) * (size_t)nvar * NC4_NUM_API_KIND * 2);
    if (!cnt) {
        DEBUG_ASSIGN_ERROR (err, NC_ENOMEM);
        goto fn_exit;
    }
    cnt_all = cnt + (size_t)nvar * NC4_NUM_API_KIND;

    reqps = (nc4_req **)NCI_Malloc (sizeof (nc4_req *) * nvar * NC4_NUM_API_KIND);
    if (!reqps) {
        DEBUG_ASSIGN_ERROR (err, NC_ENOMEM);
        goto fn_exit;
    }

    memset (cnt, 0, sizeof (int) * nvar * NC4_NUM_API_KIND);
    for (i = 0; i < nreq; i++) { cnt[reqs[i].vid * NC4_NUM_API_KIND + reqs[i].apikind]++; }
    if (coll) {
        err = MPI_Iallreduce (cnt, cnt_all, nvar * NC4_NUM_API_KIND, MPI_INT, MPI_MIN, nc4p->comm,
                              &mpireq);
        if (err != MPI_SUCCESS) {
            DEBUG_ASSIGN_ERROR (err, NC_EMPI)
            goto fn_exit;
        }
    } else {
        memset (cnt_all, 0, sizeof (int) * nvar * NC4_NUM_API_KIND);
    }

    qsort (reqs, nreq, sizeof (nc4_req), cmpfunc);

    reqps[0] = reqs;
    for (i = 1; i < nvar * NC4_NUM_API_KIND; i++) { reqps[i] = reqps[i - 1] + cnt[i - 1]; }

    if (coll) {
        err = MPI_Wait (&mpireq, &mpistat);
        if (err != MPI_SUCCESS) {
            if (err == MPI_ERR_IN_STATUS) err = mpistat.MPI_ERROR;

            DEBUG_ASSIGN_ERROR (err, NC_EMPI)
            goto fn_exit;
        }

        for (i = 0; i < nvar * NC4_NUM_API_KIND; i++) {
            for (rp = reqps[i]; rp < reqps[i] + cnt_all[i]; rp++) {
                err = nc4io_get_var (nc4p, rp->vid, rp->start, rp->count, rp->stride, rp->imap,
                                     rp->xbuf, -1, rp->buftype, NC_REQ_WR | NC_REQ_COLL);
                if (rp->idp >= 0 && statuses) {
                    if (statuses[rp->idp] == NC_NOERR) statuses[rp->idp] = err;
                }
            }
        }

        err = nc4io_begin_indep_data (nc4p);
        if (err != NC_NOERR) goto fn_exit;
    }

    for (i = 0; i < nvar * NC4_NUM_API_KIND; i++) {
        for (rp = reqps[i]; rp < reqps[i] + cnt_all[i]; rp++) {
            err = nc4io_get_var (nc4p, rp->vid, rp->start, rp->count, rp->stride, rp->imap,
                                 rp->xbuf, -1, rp->buftype, NC_REQ_WR | NC_REQ_INDEP);
            if (rp->idp >= 0 && statuses) {
                if (statuses[rp->idp] == NC_NOERR) statuses[rp->idp] = err;
            }
        }
    }

    if (coll) {
        err = nc4io_end_indep_data (nc4p);
        if (err != NC_NOERR) goto fn_exit;
    }

fn_exit:;
    return err;
}